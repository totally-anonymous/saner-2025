import argparse
import mysql.connector
import os
import re

from query_codeface import *


def arguments():
    """Define command line options."""
    parser = argparse.ArgumentParser()
    parser.add_argument("--port", required=True, help="Port")
    parser.add_argument("--data_path", required=True,
                        help="Path to data directory containing the Codeface "
                             "project run's analysis results")
    parser.add_argument("--save_path", required=False, help="Path to store \
                        the preprocessed adjacency matrices")
    return parser.parse_args()


def transpose_adjacency(df):
    """
    Transposes the matrix given by Codeface to standard matrix notation.

    Args:
        df: The matrix DataFrame.

    Returns:
        The transposed matrix DataFrame.
    """
    # Transpose matrix to correspond to the common matrix notation.
    df = df.T
    df.columns = df.index

    # Order rows and columns alphabetically.
    df = df.reindex(sorted(df.columns), axis=0)
    df = df.reindex(sorted(df.columns), axis=1)
    return df


def replace_names_adjacency(cur, df):
    """
    Replaces IDs by names in the given adjacency matrix in standard notation.

    Args:
        cur: The MySQL database connection cursor.
        df: The matrix DataFrame with person IDs as identifiers.

    Returns:
        The adjacency matrix with names and e-mail addresses as identifiers.
    """
    # Dataset with names
    for i in df.index:
        # Replace each author's ID by its name and e-mail address.
        query = "select name, email1 from person where id="+str(i)
        cur.execute(query)
        res = cur.fetchone()

        name = res[0]+" <"+res[1]+">"
        df.rename(index={i: name}, inplace=True)
        df.rename(columns={i: name}, inplace=True)

    # Order rows and columns alphabetically.
    df = df.reindex(sorted(df.columns), axis=0)
    df = df.reindex(sorted(df.columns), axis=1)
    return df


def format_adjacency(cur, data_path: str, save_path: str):
    """
    Formats an adjacency matrix in Codeface's notation to match the standard
    notation of adjacency matrices.

    Args:
        cur: The MySQL database connection cursor.
        data_path: The directory containing the Codeface analysis run results.
        save_path: The path to store the formatted adjacency matrix.

    Returns:
        The adjacency matrix in standard notation.
    """
    # Iterate all analysis time intervals.
    dirs = sorted([f for f in os.listdir(data_path) if re.match("[0-9]", f)])
    range_id_norm = 1
    for rev_range in dirs:
        # Load the adjacency matrix generated by Codeface.
        # Column headers refer to author IDs.
        matrix_path = os.path.join(data_path, rev_range, "adjacencyMatrix.txt")
        df = pd.read_csv(matrix_path, sep="\t", header=0)

        # Transpose the adjacency matrix to match the standard format.
        df = transpose_adjacency(df)

        # Save the adjacency matrix.
        save_dir_path = save_path
        save_file_path = os.path.join(save_dir_path,
                                 "range_"+str(range_id_norm)+"_adjacency_matrix.csv")
        if not os.path.exists(save_dir_path):
            os.makedirs(save_dir_path)
        df.to_csv(save_file_path, sep=",", header=True, index=True)

        # Save the adjacency matrix with developer identities.
        df = replace_names_adjacency(cur, df)
        save_file_path = os.path.join(save_dir_path,
                                      "range_"+str(range_id_norm)+"_adjacency_matrix_with_names.csv")
        df.to_csv(save_file_path, sep=",", header=True, index=True)
        range_id_norm += 1


def main(port: int, data_path: str, save_path: str = None):
    # Establish database connection.
    con = mysql.connector.connect(
        host="127.0.0.1",
        database="codeface",
        user="codeface",
        password="codeface",
        port=str(port)
    )
    cur = con.cursor(buffered=True)

    # Preprocess adjacency matrices.
    format_adjacency(cur, data_path, save_path)


if __name__ == "__main__":
    args = arguments()
    main(args.port, args.data_path, args.save_path)
