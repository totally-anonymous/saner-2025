---
title: "Network analysis"
  html_document:
    toc: true
    number_sections: true
---

# Introduction

This notebook visualises the co-change networks extracted by Codeface during commit analysis.

As a prerequisite, Codeface must be run on the desired Git project to parse the git log and to construct the adjacency matrices based on entity (i.e. files, functions and features) changes or tagging information. The adjacency matrices stored in the **res** directory will serve as input for this notebook.

```{r message=FALSE}
library(RMySQL)
library(visNetwork)
library(igraph)
library(network)
library(sna)
library(ggplot2)
library(RColorBrewer)
```

## Configuration

The following lines define the project to analyse and the path to its result (**res**) directory containing the adjacency matrices. The visualisations generated in this notebook will be written to the corresponding result directory as well.

```{r}
project <- "qemu"
res_dir <- file.path("/home/nicole/Documents/SWE/Analyses",
                     "results_comparison/codeface/", project, "proximity")
```

A connection to the Codeface database has to be established to extract additional information such as person names and e-mail addresses. The following set up assumes the installation in a Docker container with the database port being mapped to another port on the host system.

```{r}
conn <- dbConnect(RMySQL::MySQL(),
                  dbname = "codeface",
                  host = "127.0.0.1",  # Should be used instead of "localhost"
                  port = 3308,  # Port 3306 (mysql in docker) is mapped to port 3308 on the host system
                  user = "codeface",
                  password = "codeface")
```

Get an overview on all available database tables.

```{r}
dbListTables(conn)
```


# Adjacency matrices

Preprocess the adjacency matrices of all time ranges and replace the authors' IDs by their name and e-mail-addresses to facilitate the comparison of the network structures generated by Codeface and those generated by other tools.

```{r}
# Get result directories for all time ranges
dirs <- list.dirs(res_dir)
dirs <- dirs[grepl("[0-9]", dirs)]

adjacency_matrices <- list()

for (i in seq_along(dirs)) {
  if (i != 27) {
    next
  }
  
  # Load the adjacency matrix generated by Codeface
  # Column headers refer to author IDs
  df <- read.table(file.path(dirs[i], "adjacencyMatrix.txt"),
                   sep = "\t", header = TRUE, check.names = FALSE)

  for (j in seq_along(colnames(df))) {
    # Replace the author's ID by its name and e-mail address
    query <- paste("select name, email1 from person where id =",
                    as.character(colnames(df)[j]))
    res <- dbGetQuery(conn, query)

    colnames(df)[j] <- rownames(df)[j] <- paste(res$name, " <",
                                                res$email1, ">", sep = "")
  }
  
  # Order rows and columns alphabetically
  if (length(colnames(df)) > 1) {
    df <- df[order(rownames(df)),]
    df <- df[,order(colnames(df))]
  }
  
  # Save the preprocessed adjacency matrix for further analyses
  write.csv(df, file.path(dirs[i], "adjacency_matrix.csv"), row.names=TRUE)
  adjacency_matrices[[i]] <- df
}
```

```{r}
# g <- igraph::graph_from_adjacency_matrix(data.matrix(adjacency_matrices[[8]]))
# g <- simplify(g, remove.multiple = TRUE, remove.loops = FALSE)
# visIgraph(g)
```

# Network graphs

Plot the collaboration network for each time range based on the preprocessed
adjacency matrices constructed by Codeface.

```{r}
plot_network_graph <- function(g) {
  # Adjust the graph layout and formatting to improve readability
  # when saving the graph to file
  # TODO scale the parameters reasonably instead of hard coding values
  deg <- igraph::degree(g, mode="all")
  if (length(igraph::V(g)) < 15) {
    vertex_size <- 5 + deg/5
    vertex_label_cex <- 50
    vertex_label_dist <- 1.5
    edge_arrow_size <- 20
    margin <- 0.3
  } else if (length(igraph::V(g)) < 70) {
    vertex_size <- 3 + deg/5
    vertex_label_cex <- 20 + deg/5
    vertex_label_dist <- 0.7
    edge_arrow_size <- 10
    margin <- 0
  } else {
    vertex_size <- 2 + deg/20
    vertex_label_cex <- 5 + deg/15
    vertex_label_dist <- 0.7
    edge_arrow_size <- 6
    margin <- 0
  }
  # Color nodes according to their eigenvector centrality
  # Eigenvector centrality expresses a node's centrality depending
  # on the centrality of its neighbors
  # Nodes with a high degree are connected to other nodes
  # with a high degree
  V(g)$ec <- eigen_centrality(g, directed=T, weights=NA)$vector
  normalize <- function(x){(x-min(x))/(max(x)-min(x))}
  (V(g)$ec_index <- round(normalize(V(g)$ec) * 19) + 1)
  V(g)$color <- colorRampPalette(c("turquoise", "yellow", "red"))(20)[V(g)$ec_index]
  # Scale the edge width according to the edge weight
  if (max(igraph::E(g)$weight) == 1) {
    igraph::E(g)$weight <- 0.8
  } else {
    igraph::E(g)$weight <- 0.8 + (200 * igraph::E(g)$weight/max(igraph::E(g)$weight))
  }
  # Adjust the graph layout to make better use of the available space
  lo <- layout_with_kk(g)
  lo <- norm_coords(lo, ymin=-1, ymax=1, xmin=-1, xmax=1)
  # Plot the customized graph
  plot(g,
  vertex.size = vertex_size,
  vertex.label.cex = vertex_label_cex,
  vertex_label_dist = vertex_label_dist,
  vertex.label = igraph::V(g)$names,
  vertex.label.family = "sans",
  vertex.label.color = "#000000",
  vertex.frame.width = 0.02,
  vertex.frame.color = "#AAAAAA",
  edge.color = "#AAAAAA",
  edge.arrow.size = edge_arrow_size,
  edge.width = igraph::E(g)$weight,
  margin = margin,
  rescale = FALSE,
  layout=lo*0.9)
  dev.off()
}
plot_heatmap <- function(g, plot_file) {
  pdf(plot_file, height = 800, width = 800)
  oldpar <- par(mar = rep(0.1, 4))  # Reduce plot margin
  rotate <- function(df) t(apply(data.matrix(df), 2, rev))
  image(rotate(df),
        col = colorRampPalette(c( "lightblue", "blue", "darkblue", "black"))(50),
        useRaster=TRUE,
        breaks = c(seq(1, 50, length.out = 50), 5000))
  box()
  dev.off()
}
```

```{r}
# Get result directories for all time ranges
dirs <- list.dirs(res_dir)
dirs <- dirs[grepl("[0-9]", dirs)]

for (i in seq_along(dirs)) {
  if (i != 27) {
    next
  }
  
  # Read and format the adjacency matrix
  df <- read.csv(file.path(dirs[i], "adjacency_matrix.csv"),
                 sep = ",", header = TRUE, check.names = FALSE)
  rownames(df) <- df[,1]
  df[,1] <- NULL
  matrix <- data.matrix(df)

  # Create a network plot from the adjacency matrix
  g <- igraph::graph_from_adjacency_matrix(matrix)
  igraph::E(g)$weight <- 1
  g <- igraph::simplify(g, remove.multiple = TRUE, remove.loops = TRUE, 
                        edge.attr.comb=list(weight="sum"))
  
  # Save the network plot to file
  pdf(file.path(dirs[i], "network_graph.pdf"), height = 800, width = 1000)
  plot_network_graph(g)
  
  # Plot the adjacency matrix as a heatmap
  plot_file <- file.path(dirs[i], "network_heatmap.pdf")
  plot_heatmap(g, plot_file)
}
```

## Experiments

```{r}
df <- read.csv("/home/nicole/Documents/SWE/Analyses/results_comparison/kaiaulu/res/qemu_individual/entity/2008-02-11_2008-11-08/author_temporal_adjacency_matrix.csv")
g <- graph_from_data_frame(df)
g
```


